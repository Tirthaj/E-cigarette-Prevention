<div>
    <h1 style=" text-align: center;">E-Cigarette Awareness</h1>
</div>
<span id="fps">--</span> FPS</div>
<div id='webcam-container'>
</div>
<div id='label-container'></div>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.3.1/dist/tf.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@teachablemachine/image@0.8.3/dist/teachablemachine-image.min.js"></script>
<script type="text/javascript">
    // More API functions here:
    // https://github.com/googlecreativelab/teachablemachine-community/tree/master/libraries/image
    let counter = 0;
    let maxname = "";
    var fps = document.getElementById("fps");
    var startTime = Date.now();
    var frame = 0;
    // the link to your model provided by Teachable Machine export panel
    const URL = 'https://teachablemachine.withgoogle.com/models/9UUcfiGdl/';

    let model, webcam, labelContainer, maxPredictions;

    let isIos = false;
    // fix when running demo in ios, video will be frozen;
    if (window.navigator.userAgent.indexOf('iPhone') > -1 || window.navigator.userAgent.indexOf('iPad') > -1) {
      isIos = true;
    }
    // Load the image model and setup the webcam
    init();
    async function init() {
  const modelURL = URL + 'model.json';
  const metadataURL = URL + 'metadata.json';

  // load the model and metadata
  // Refer to tmImage.loadFromFiles() in the API to support files from a file picker
  // or files from your local hard drive
  model = await tmImage.load(modelURL, metadataURL);
  maxPredictions = model.getTotalClasses();

  // Convenience function to setup a webcam
  const flip = true; // whether to flip the webcam
  const screenWidth = screen.width;
  const screenHeight = screen.height;
  const webcamWidth = screenWidth;
  const webcamHeight = screenHeight;
  webcam = new tmImage.Webcam(webcamWidth, webcamHeight, flip);
  await webcam.setup(); // request access to the webcam

  // Set the webcam to full screen
  //webcam.canvas.style.position = 'fixed';
//   webcam.canvas.style.top = '0';
//   webcam.canvas.style.left = '0';
//   webcam.canvas.style.bottom = '0';
//   webcam.canvas.style.right = '0';

  if (isIos) {
    document.getElementById('webcam-container').appendChild(webcam.webcam); // webcam object needs to be added in any case to make this work on iOS
    // grab video-object in any way you want and set the attributes
    const webCamVideo = document.getElementsByTagName('video')[0];
    webCamVideo.setAttribute('playsinline', true); // written with "setAttribute" bc. iOS buggs otherwise
    webCamVideo.muted = 'true';
    webCamVideo.style.width = screenWidth + 'px'; //967
    webCamVideo.style.height = screenHeight + 'px'; //1782
  } else {
    document.getElementById('webcam-container').appendChild(webcam.canvas);
  }
  // append elements to the DOM
  labelContainer = document.getElementById('label-container');
  for (let i = 0; i < maxPredictions; i++) {
    // and class labels
    labelContainer.appendChild(document.createElement('div'));
  }
  webcam.play();
  window.requestAnimationFrame(loop);
}


    async function loop() {
        webcam.update(); // update the webcam frame
        await predict();
        window.requestAnimationFrame(loop);
    }

    // run the webcam image through the image model
    async function predict() {
        // predict can take in an image, video or canvas html element
        let prediction;
        if (isIos) {
            prediction = await model.predict(webcam.webcam);
        } else {
            prediction = await model.predict(webcam.canvas);
        }
        
        for (let i = 0; i < maxPredictions; i++) {
            const classPrediction =
                prediction[i].className + ': ' + prediction[i].probability.toFixed(2);
                if (prediction[i].probability.toFixed(2) > 0.85){
                    maxname = prediction[i].className;
                    console.log(maxname);
                    counter ++;
                    console.log("Counter" +counter);
                    if (counter > 200){
                        console.log("For long" +maxname)
                        // Redirect
                        if (maxname == 'Blank'){
                            counter = 0;
                            continue;
                        }
                        else if (maxname=='Blume E-Cigarette'){
                            window.location.href = "https://tirthaj.github.io/E-cigarette-Prevention/Blume_warning.html";
                        }
                        else if (maxname=='Swift E-cigarette'){
                            window.location.href = "https://tirthaj.github.io/E-cigarette-Prevention/Swift_warning.html";
                        }
                        else if (maxname=='Diamond E-cigarette'){
                            window.location.href = "https://tirthaj.github.io/E-cigarette-Prevention/Diamond_warning.html";
                        }
                        else if (maxname=='Golden E-cigarette'){
                            window.location.href = "https://tirthaj.github.io/E-cigarette-Prevention/Lux_warning.html";
                        }
                        // window.location.href = "https://tirthaj.github.io/WebAR-TT/";
                        counter = 0;
                    }
                }
                // else{

                //     counter = 0;
                // }
                // console.log(classPrediction);
        }
    }
    function tick() {
    var time = Date.now();
    frame++;
    if (time - startTime > 1000) {
        fps.innerHTML = (frame / ((time - startTime) / 1000)).toFixed(1);
        startTime = time;
        frame = 0;
        }
    window.requestAnimationFrame(tick);
    }
    tick();
</script>
